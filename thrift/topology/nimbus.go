// Autogenerated by Thrift Compiler (0.9.2)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package topology

import (
	"bytes"
	"fmt"

	"git.apache.org/thrift.git/lib/go/thrift"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = bytes.Equal

type Nimbus interface {
	// Parameters:
	//  - Name
	//  - UploadedJarLocation
	//  - JsonConf
	//  - Topology
	SubmitTopology(name string, uploadedJarLocation string, jsonConf string, topology *StormTopology) (err error)
	// Parameters:
	//  - Name
	//  - UploadedJarLocation
	//  - JsonConf
	//  - Topology
	//  - Options
	SubmitTopologyWithOpts(name string, uploadedJarLocation string, jsonConf string, topology *StormTopology, options *SubmitOptions) (err error)
	// Parameters:
	//  - Name
	KillTopology(name string) (err error)
	// Parameters:
	//  - Name
	//  - Options
	KillTopologyWithOpts(name string, options *KillOptions) (err error)
	// Parameters:
	//  - Name
	Activate(name string) (err error)
	// Parameters:
	//  - Name
	Deactivate(name string) (err error)
	// Parameters:
	//  - Name
	//  - Options
	Rebalance(name string, options *RebalanceOptions) (err error)
	// Parameters:
	//  - Name
	//  - Creds
	UploadNewCredentials(name string, creds *Credentials) (err error)
	BeginFileUpload() (r string, err error)
	// Parameters:
	//  - Location
	//  - Chunk
	UploadChunk(location string, chunk []byte) (err error)
	// Parameters:
	//  - Location
	FinishFileUpload(location string) (err error)
	// Parameters:
	//  - File
	BeginFileDownload(file string) (r string, err error)
	// Parameters:
	//  - Id
	DownloadChunk(id string) (r []byte, err error)
	GetNimbusConf() (r string, err error)
	GetClusterInfo() (r *ClusterSummary, err error)
	// Parameters:
	//  - Id
	GetTopologyInfo(id string) (r *TopologyInfo, err error)
	// Parameters:
	//  - Id
	GetTopologyConf(id string) (r string, err error)
	// Parameters:
	//  - Id
	GetTopology(id string) (r *StormTopology, err error)
	// Parameters:
	//  - Id
	GetUserTopology(id string) (r *StormTopology, err error)
}

type NimbusClient struct {
	Transport       thrift.TTransport
	ProtocolFactory thrift.TProtocolFactory
	InputProtocol   thrift.TProtocol
	OutputProtocol  thrift.TProtocol
	SeqId           int32
}

func NewNimbusClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *NimbusClient {
	return &NimbusClient{Transport: t,
		ProtocolFactory: f,
		InputProtocol:   f.GetProtocol(t),
		OutputProtocol:  f.GetProtocol(t),
		SeqId:           0,
	}
}

func NewNimbusClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *NimbusClient {
	return &NimbusClient{Transport: t,
		ProtocolFactory: nil,
		InputProtocol:   iprot,
		OutputProtocol:  oprot,
		SeqId:           0,
	}
}

// Parameters:
//  - Name
//  - UploadedJarLocation
//  - JsonConf
//  - Topology
func (p *NimbusClient) SubmitTopology(name string, uploadedJarLocation string, jsonConf string, topology *StormTopology) (err error) {
	if err = p.sendSubmitTopology(name, uploadedJarLocation, jsonConf, topology); err != nil {
		return
	}
	return p.recvSubmitTopology()
}

func (p *NimbusClient) sendSubmitTopology(name string, uploadedJarLocation string, jsonConf string, topology *StormTopology) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("submitTopology", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := SubmitTopologyArgs{
		Name:                name,
		UploadedJarLocation: uploadedJarLocation,
		JsonConf:            jsonConf,
		Topology:            topology,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *NimbusClient) recvSubmitTopology() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error63 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error64 error
		error64, err = error63.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error64
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "submitTopology failed: out of sequence response")
		return
	}
	result := SubmitTopologyResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.E != nil {
		err = result.E
		return
	} else if result.Ite != nil {
		err = result.Ite
		return
	} else if result.Aze != nil {
		err = result.Aze
		return
	}
	return
}

// Parameters:
//  - Name
//  - UploadedJarLocation
//  - JsonConf
//  - Topology
//  - Options
func (p *NimbusClient) SubmitTopologyWithOpts(name string, uploadedJarLocation string, jsonConf string, topology *StormTopology, options *SubmitOptions) (err error) {
	if err = p.sendSubmitTopologyWithOpts(name, uploadedJarLocation, jsonConf, topology, options); err != nil {
		return
	}
	return p.recvSubmitTopologyWithOpts()
}

func (p *NimbusClient) sendSubmitTopologyWithOpts(name string, uploadedJarLocation string, jsonConf string, topology *StormTopology, options *SubmitOptions) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("submitTopologyWithOpts", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := SubmitTopologyWithOptsArgs{
		Name:                name,
		UploadedJarLocation: uploadedJarLocation,
		JsonConf:            jsonConf,
		Topology:            topology,
		Options:             options,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *NimbusClient) recvSubmitTopologyWithOpts() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error65 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error66 error
		error66, err = error65.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error66
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "submitTopologyWithOpts failed: out of sequence response")
		return
	}
	result := SubmitTopologyWithOptsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.E != nil {
		err = result.E
		return
	} else if result.Ite != nil {
		err = result.Ite
		return
	} else if result.Aze != nil {
		err = result.Aze
		return
	}
	return
}

// Parameters:
//  - Name
func (p *NimbusClient) KillTopology(name string) (err error) {
	if err = p.sendKillTopology(name); err != nil {
		return
	}
	return p.recvKillTopology()
}

func (p *NimbusClient) sendKillTopology(name string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("killTopology", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := KillTopologyArgs{
		Name: name,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *NimbusClient) recvKillTopology() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error67 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error68 error
		error68, err = error67.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error68
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "killTopology failed: out of sequence response")
		return
	}
	result := KillTopologyResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.E != nil {
		err = result.E
		return
	} else if result.Aze != nil {
		err = result.Aze
		return
	}
	return
}

// Parameters:
//  - Name
//  - Options
func (p *NimbusClient) KillTopologyWithOpts(name string, options *KillOptions) (err error) {
	if err = p.sendKillTopologyWithOpts(name, options); err != nil {
		return
	}
	return p.recvKillTopologyWithOpts()
}

func (p *NimbusClient) sendKillTopologyWithOpts(name string, options *KillOptions) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("killTopologyWithOpts", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := KillTopologyWithOptsArgs{
		Name:    name,
		Options: options,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *NimbusClient) recvKillTopologyWithOpts() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error69 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error70 error
		error70, err = error69.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error70
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "killTopologyWithOpts failed: out of sequence response")
		return
	}
	result := KillTopologyWithOptsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.E != nil {
		err = result.E
		return
	} else if result.Aze != nil {
		err = result.Aze
		return
	}
	return
}

// Parameters:
//  - Name
func (p *NimbusClient) Activate(name string) (err error) {
	if err = p.sendActivate(name); err != nil {
		return
	}
	return p.recvActivate()
}

func (p *NimbusClient) sendActivate(name string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("activate", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := ActivateArgs{
		Name: name,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *NimbusClient) recvActivate() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error71 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error72 error
		error72, err = error71.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error72
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "activate failed: out of sequence response")
		return
	}
	result := ActivateResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.E != nil {
		err = result.E
		return
	} else if result.Aze != nil {
		err = result.Aze
		return
	}
	return
}

// Parameters:
//  - Name
func (p *NimbusClient) Deactivate(name string) (err error) {
	if err = p.sendDeactivate(name); err != nil {
		return
	}
	return p.recvDeactivate()
}

func (p *NimbusClient) sendDeactivate(name string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("deactivate", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := DeactivateArgs{
		Name: name,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *NimbusClient) recvDeactivate() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error73 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error74 error
		error74, err = error73.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error74
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "deactivate failed: out of sequence response")
		return
	}
	result := DeactivateResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.E != nil {
		err = result.E
		return
	} else if result.Aze != nil {
		err = result.Aze
		return
	}
	return
}

// Parameters:
//  - Name
//  - Options
func (p *NimbusClient) Rebalance(name string, options *RebalanceOptions) (err error) {
	if err = p.sendRebalance(name, options); err != nil {
		return
	}
	return p.recvRebalance()
}

func (p *NimbusClient) sendRebalance(name string, options *RebalanceOptions) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("rebalance", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := RebalanceArgs{
		Name:    name,
		Options: options,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *NimbusClient) recvRebalance() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error75 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error76 error
		error76, err = error75.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error76
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "rebalance failed: out of sequence response")
		return
	}
	result := RebalanceResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.E != nil {
		err = result.E
		return
	} else if result.Ite != nil {
		err = result.Ite
		return
	} else if result.Aze != nil {
		err = result.Aze
		return
	}
	return
}

// Parameters:
//  - Name
//  - Creds
func (p *NimbusClient) UploadNewCredentials(name string, creds *Credentials) (err error) {
	if err = p.sendUploadNewCredentials(name, creds); err != nil {
		return
	}
	return p.recvUploadNewCredentials()
}

func (p *NimbusClient) sendUploadNewCredentials(name string, creds *Credentials) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("uploadNewCredentials", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := UploadNewCredentialsArgs{
		Name:  name,
		Creds: creds,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *NimbusClient) recvUploadNewCredentials() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error77 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error78 error
		error78, err = error77.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error78
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "uploadNewCredentials failed: out of sequence response")
		return
	}
	result := UploadNewCredentialsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.E != nil {
		err = result.E
		return
	} else if result.Ite != nil {
		err = result.Ite
		return
	} else if result.Aze != nil {
		err = result.Aze
		return
	}
	return
}

func (p *NimbusClient) BeginFileUpload() (r string, err error) {
	if err = p.sendBeginFileUpload(); err != nil {
		return
	}
	return p.recvBeginFileUpload()
}

func (p *NimbusClient) sendBeginFileUpload() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("beginFileUpload", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := BeginFileUploadArgs{}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *NimbusClient) recvBeginFileUpload() (value string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error79 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error80 error
		error80, err = error79.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error80
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "beginFileUpload failed: out of sequence response")
		return
	}
	result := BeginFileUploadResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Aze != nil {
		err = result.Aze
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Location
//  - Chunk
func (p *NimbusClient) UploadChunk(location string, chunk []byte) (err error) {
	if err = p.sendUploadChunk(location, chunk); err != nil {
		return
	}
	return p.recvUploadChunk()
}

func (p *NimbusClient) sendUploadChunk(location string, chunk []byte) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("uploadChunk", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := UploadChunkArgs{
		Location: location,
		Chunk:    chunk,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *NimbusClient) recvUploadChunk() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error81 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error82 error
		error82, err = error81.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error82
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "uploadChunk failed: out of sequence response")
		return
	}
	result := UploadChunkResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Aze != nil {
		err = result.Aze
		return
	}
	return
}

// Parameters:
//  - Location
func (p *NimbusClient) FinishFileUpload(location string) (err error) {
	if err = p.sendFinishFileUpload(location); err != nil {
		return
	}
	return p.recvFinishFileUpload()
}

func (p *NimbusClient) sendFinishFileUpload(location string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("finishFileUpload", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := FinishFileUploadArgs{
		Location: location,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *NimbusClient) recvFinishFileUpload() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error83 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error84 error
		error84, err = error83.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error84
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "finishFileUpload failed: out of sequence response")
		return
	}
	result := FinishFileUploadResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Aze != nil {
		err = result.Aze
		return
	}
	return
}

// Parameters:
//  - File
func (p *NimbusClient) BeginFileDownload(file string) (r string, err error) {
	if err = p.sendBeginFileDownload(file); err != nil {
		return
	}
	return p.recvBeginFileDownload()
}

func (p *NimbusClient) sendBeginFileDownload(file string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("beginFileDownload", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := BeginFileDownloadArgs{
		File: file,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *NimbusClient) recvBeginFileDownload() (value string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error85 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error86 error
		error86, err = error85.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error86
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "beginFileDownload failed: out of sequence response")
		return
	}
	result := BeginFileDownloadResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Aze != nil {
		err = result.Aze
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Id
func (p *NimbusClient) DownloadChunk(id string) (r []byte, err error) {
	if err = p.sendDownloadChunk(id); err != nil {
		return
	}
	return p.recvDownloadChunk()
}

func (p *NimbusClient) sendDownloadChunk(id string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("downloadChunk", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := DownloadChunkArgs{
		Id: id,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *NimbusClient) recvDownloadChunk() (value []byte, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error87 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error88 error
		error88, err = error87.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error88
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "downloadChunk failed: out of sequence response")
		return
	}
	result := DownloadChunkResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Aze != nil {
		err = result.Aze
		return
	}
	value = result.GetSuccess()
	return
}

func (p *NimbusClient) GetNimbusConf() (r string, err error) {
	if err = p.sendGetNimbusConf(); err != nil {
		return
	}
	return p.recvGetNimbusConf()
}

func (p *NimbusClient) sendGetNimbusConf() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getNimbusConf", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetNimbusConfArgs{}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *NimbusClient) recvGetNimbusConf() (value string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error89 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error90 error
		error90, err = error89.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error90
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getNimbusConf failed: out of sequence response")
		return
	}
	result := GetNimbusConfResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Aze != nil {
		err = result.Aze
		return
	}
	value = result.GetSuccess()
	return
}

func (p *NimbusClient) GetClusterInfo() (r *ClusterSummary, err error) {
	if err = p.sendGetClusterInfo(); err != nil {
		return
	}
	return p.recvGetClusterInfo()
}

func (p *NimbusClient) sendGetClusterInfo() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getClusterInfo", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetClusterInfoArgs{}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *NimbusClient) recvGetClusterInfo() (value *ClusterSummary, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error91 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error92 error
		error92, err = error91.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error92
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getClusterInfo failed: out of sequence response")
		return
	}
	result := GetClusterInfoResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Aze != nil {
		err = result.Aze
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Id
func (p *NimbusClient) GetTopologyInfo(id string) (r *TopologyInfo, err error) {
	if err = p.sendGetTopologyInfo(id); err != nil {
		return
	}
	return p.recvGetTopologyInfo()
}

func (p *NimbusClient) sendGetTopologyInfo(id string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getTopologyInfo", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetTopologyInfoArgs{
		Id: id,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *NimbusClient) recvGetTopologyInfo() (value *TopologyInfo, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error93 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error94 error
		error94, err = error93.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error94
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getTopologyInfo failed: out of sequence response")
		return
	}
	result := GetTopologyInfoResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.E != nil {
		err = result.E
		return
	} else if result.Aze != nil {
		err = result.Aze
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Id
func (p *NimbusClient) GetTopologyConf(id string) (r string, err error) {
	if err = p.sendGetTopologyConf(id); err != nil {
		return
	}
	return p.recvGetTopologyConf()
}

func (p *NimbusClient) sendGetTopologyConf(id string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getTopologyConf", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetTopologyConfArgs{
		Id: id,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *NimbusClient) recvGetTopologyConf() (value string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error95 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error96 error
		error96, err = error95.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error96
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getTopologyConf failed: out of sequence response")
		return
	}
	result := GetTopologyConfResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.E != nil {
		err = result.E
		return
	} else if result.Aze != nil {
		err = result.Aze
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Id
func (p *NimbusClient) GetTopology(id string) (r *StormTopology, err error) {
	if err = p.sendGetTopology(id); err != nil {
		return
	}
	return p.recvGetTopology()
}

func (p *NimbusClient) sendGetTopology(id string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getTopology", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetTopologyArgs{
		Id: id,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *NimbusClient) recvGetTopology() (value *StormTopology, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error97 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error98 error
		error98, err = error97.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error98
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getTopology failed: out of sequence response")
		return
	}
	result := GetTopologyResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.E != nil {
		err = result.E
		return
	} else if result.Aze != nil {
		err = result.Aze
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Id
func (p *NimbusClient) GetUserTopology(id string) (r *StormTopology, err error) {
	if err = p.sendGetUserTopology(id); err != nil {
		return
	}
	return p.recvGetUserTopology()
}

func (p *NimbusClient) sendGetUserTopology(id string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getUserTopology", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetUserTopologyArgs{
		Id: id,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *NimbusClient) recvGetUserTopology() (value *StormTopology, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error99 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error100 error
		error100, err = error99.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error100
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getUserTopology failed: out of sequence response")
		return
	}
	result := GetUserTopologyResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.E != nil {
		err = result.E
		return
	} else if result.Aze != nil {
		err = result.Aze
		return
	}
	value = result.GetSuccess()
	return
}

type NimbusProcessor struct {
	processorMap map[string]thrift.TProcessorFunction
	handler      Nimbus
}

func (p *NimbusProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
	p.processorMap[key] = processor
}

func (p *NimbusProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
	processor, ok = p.processorMap[key]
	return processor, ok
}

func (p *NimbusProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
	return p.processorMap
}

func NewNimbusProcessor(handler Nimbus) *NimbusProcessor {

	self101 := &NimbusProcessor{handler: handler, processorMap: make(map[string]thrift.TProcessorFunction)}
	self101.processorMap["submitTopology"] = &nimbusProcessorSubmitTopology{handler: handler}
	self101.processorMap["submitTopologyWithOpts"] = &nimbusProcessorSubmitTopologyWithOpts{handler: handler}
	self101.processorMap["killTopology"] = &nimbusProcessorKillTopology{handler: handler}
	self101.processorMap["killTopologyWithOpts"] = &nimbusProcessorKillTopologyWithOpts{handler: handler}
	self101.processorMap["activate"] = &nimbusProcessorActivate{handler: handler}
	self101.processorMap["deactivate"] = &nimbusProcessorDeactivate{handler: handler}
	self101.processorMap["rebalance"] = &nimbusProcessorRebalance{handler: handler}
	self101.processorMap["uploadNewCredentials"] = &nimbusProcessorUploadNewCredentials{handler: handler}
	self101.processorMap["beginFileUpload"] = &nimbusProcessorBeginFileUpload{handler: handler}
	self101.processorMap["uploadChunk"] = &nimbusProcessorUploadChunk{handler: handler}
	self101.processorMap["finishFileUpload"] = &nimbusProcessorFinishFileUpload{handler: handler}
	self101.processorMap["beginFileDownload"] = &nimbusProcessorBeginFileDownload{handler: handler}
	self101.processorMap["downloadChunk"] = &nimbusProcessorDownloadChunk{handler: handler}
	self101.processorMap["getNimbusConf"] = &nimbusProcessorGetNimbusConf{handler: handler}
	self101.processorMap["getClusterInfo"] = &nimbusProcessorGetClusterInfo{handler: handler}
	self101.processorMap["getTopologyInfo"] = &nimbusProcessorGetTopologyInfo{handler: handler}
	self101.processorMap["getTopologyConf"] = &nimbusProcessorGetTopologyConf{handler: handler}
	self101.processorMap["getTopology"] = &nimbusProcessorGetTopology{handler: handler}
	self101.processorMap["getUserTopology"] = &nimbusProcessorGetUserTopology{handler: handler}
	return self101
}

func (p *NimbusProcessor) Process(iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	name, _, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return false, err
	}
	if processor, ok := p.GetProcessorFunction(name); ok {
		return processor.Process(seqId, iprot, oprot)
	}
	iprot.Skip(thrift.STRUCT)
	iprot.ReadMessageEnd()
	x102 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function "+name)
	oprot.WriteMessageBegin(name, thrift.EXCEPTION, seqId)
	x102.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return false, x102

}

type nimbusProcessorSubmitTopology struct {
	handler Nimbus
}

func (p *nimbusProcessorSubmitTopology) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := SubmitTopologyArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("submitTopology", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := SubmitTopologyResult{}
	var err2 error
	if err2 = p.handler.SubmitTopology(args.Name, args.UploadedJarLocation, args.JsonConf, args.Topology); err2 != nil {
		switch v := err2.(type) {
		case *AlreadyAliveException:
			result.E = v
		case *InvalidTopologyException:
			result.Ite = v
		case *AuthorizationException:
			result.Aze = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing submitTopology: "+err2.Error())
			oprot.WriteMessageBegin("submitTopology", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("submitTopology", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type nimbusProcessorSubmitTopologyWithOpts struct {
	handler Nimbus
}

func (p *nimbusProcessorSubmitTopologyWithOpts) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := SubmitTopologyWithOptsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("submitTopologyWithOpts", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := SubmitTopologyWithOptsResult{}
	var err2 error
	if err2 = p.handler.SubmitTopologyWithOpts(args.Name, args.UploadedJarLocation, args.JsonConf, args.Topology, args.Options); err2 != nil {
		switch v := err2.(type) {
		case *AlreadyAliveException:
			result.E = v
		case *InvalidTopologyException:
			result.Ite = v
		case *AuthorizationException:
			result.Aze = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing submitTopologyWithOpts: "+err2.Error())
			oprot.WriteMessageBegin("submitTopologyWithOpts", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("submitTopologyWithOpts", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type nimbusProcessorKillTopology struct {
	handler Nimbus
}

func (p *nimbusProcessorKillTopology) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := KillTopologyArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("killTopology", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := KillTopologyResult{}
	var err2 error
	if err2 = p.handler.KillTopology(args.Name); err2 != nil {
		switch v := err2.(type) {
		case *NotAliveException:
			result.E = v
		case *AuthorizationException:
			result.Aze = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing killTopology: "+err2.Error())
			oprot.WriteMessageBegin("killTopology", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("killTopology", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type nimbusProcessorKillTopologyWithOpts struct {
	handler Nimbus
}

func (p *nimbusProcessorKillTopologyWithOpts) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := KillTopologyWithOptsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("killTopologyWithOpts", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := KillTopologyWithOptsResult{}
	var err2 error
	if err2 = p.handler.KillTopologyWithOpts(args.Name, args.Options); err2 != nil {
		switch v := err2.(type) {
		case *NotAliveException:
			result.E = v
		case *AuthorizationException:
			result.Aze = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing killTopologyWithOpts: "+err2.Error())
			oprot.WriteMessageBegin("killTopologyWithOpts", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("killTopologyWithOpts", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type nimbusProcessorActivate struct {
	handler Nimbus
}

func (p *nimbusProcessorActivate) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ActivateArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("activate", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := ActivateResult{}
	var err2 error
	if err2 = p.handler.Activate(args.Name); err2 != nil {
		switch v := err2.(type) {
		case *NotAliveException:
			result.E = v
		case *AuthorizationException:
			result.Aze = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing activate: "+err2.Error())
			oprot.WriteMessageBegin("activate", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("activate", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type nimbusProcessorDeactivate struct {
	handler Nimbus
}

func (p *nimbusProcessorDeactivate) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := DeactivateArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("deactivate", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := DeactivateResult{}
	var err2 error
	if err2 = p.handler.Deactivate(args.Name); err2 != nil {
		switch v := err2.(type) {
		case *NotAliveException:
			result.E = v
		case *AuthorizationException:
			result.Aze = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deactivate: "+err2.Error())
			oprot.WriteMessageBegin("deactivate", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("deactivate", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type nimbusProcessorRebalance struct {
	handler Nimbus
}

func (p *nimbusProcessorRebalance) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := RebalanceArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("rebalance", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := RebalanceResult{}
	var err2 error
	if err2 = p.handler.Rebalance(args.Name, args.Options); err2 != nil {
		switch v := err2.(type) {
		case *NotAliveException:
			result.E = v
		case *InvalidTopologyException:
			result.Ite = v
		case *AuthorizationException:
			result.Aze = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing rebalance: "+err2.Error())
			oprot.WriteMessageBegin("rebalance", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("rebalance", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type nimbusProcessorUploadNewCredentials struct {
	handler Nimbus
}

func (p *nimbusProcessorUploadNewCredentials) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := UploadNewCredentialsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("uploadNewCredentials", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := UploadNewCredentialsResult{}
	var err2 error
	if err2 = p.handler.UploadNewCredentials(args.Name, args.Creds); err2 != nil {
		switch v := err2.(type) {
		case *NotAliveException:
			result.E = v
		case *InvalidTopologyException:
			result.Ite = v
		case *AuthorizationException:
			result.Aze = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing uploadNewCredentials: "+err2.Error())
			oprot.WriteMessageBegin("uploadNewCredentials", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("uploadNewCredentials", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type nimbusProcessorBeginFileUpload struct {
	handler Nimbus
}

func (p *nimbusProcessorBeginFileUpload) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := BeginFileUploadArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("beginFileUpload", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := BeginFileUploadResult{}
	var retval string
	var err2 error
	if retval, err2 = p.handler.BeginFileUpload(); err2 != nil {
		switch v := err2.(type) {
		case *AuthorizationException:
			result.Aze = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing beginFileUpload: "+err2.Error())
			oprot.WriteMessageBegin("beginFileUpload", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("beginFileUpload", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type nimbusProcessorUploadChunk struct {
	handler Nimbus
}

func (p *nimbusProcessorUploadChunk) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := UploadChunkArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("uploadChunk", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := UploadChunkResult{}
	var err2 error
	if err2 = p.handler.UploadChunk(args.Location, args.Chunk); err2 != nil {
		switch v := err2.(type) {
		case *AuthorizationException:
			result.Aze = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing uploadChunk: "+err2.Error())
			oprot.WriteMessageBegin("uploadChunk", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("uploadChunk", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type nimbusProcessorFinishFileUpload struct {
	handler Nimbus
}

func (p *nimbusProcessorFinishFileUpload) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := FinishFileUploadArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("finishFileUpload", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := FinishFileUploadResult{}
	var err2 error
	if err2 = p.handler.FinishFileUpload(args.Location); err2 != nil {
		switch v := err2.(type) {
		case *AuthorizationException:
			result.Aze = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing finishFileUpload: "+err2.Error())
			oprot.WriteMessageBegin("finishFileUpload", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("finishFileUpload", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type nimbusProcessorBeginFileDownload struct {
	handler Nimbus
}

func (p *nimbusProcessorBeginFileDownload) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := BeginFileDownloadArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("beginFileDownload", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := BeginFileDownloadResult{}
	var retval string
	var err2 error
	if retval, err2 = p.handler.BeginFileDownload(args.File); err2 != nil {
		switch v := err2.(type) {
		case *AuthorizationException:
			result.Aze = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing beginFileDownload: "+err2.Error())
			oprot.WriteMessageBegin("beginFileDownload", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("beginFileDownload", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type nimbusProcessorDownloadChunk struct {
	handler Nimbus
}

func (p *nimbusProcessorDownloadChunk) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := DownloadChunkArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("downloadChunk", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := DownloadChunkResult{}
	var retval []byte
	var err2 error
	if retval, err2 = p.handler.DownloadChunk(args.Id); err2 != nil {
		switch v := err2.(type) {
		case *AuthorizationException:
			result.Aze = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing downloadChunk: "+err2.Error())
			oprot.WriteMessageBegin("downloadChunk", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("downloadChunk", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type nimbusProcessorGetNimbusConf struct {
	handler Nimbus
}

func (p *nimbusProcessorGetNimbusConf) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetNimbusConfArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getNimbusConf", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetNimbusConfResult{}
	var retval string
	var err2 error
	if retval, err2 = p.handler.GetNimbusConf(); err2 != nil {
		switch v := err2.(type) {
		case *AuthorizationException:
			result.Aze = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getNimbusConf: "+err2.Error())
			oprot.WriteMessageBegin("getNimbusConf", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("getNimbusConf", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type nimbusProcessorGetClusterInfo struct {
	handler Nimbus
}

func (p *nimbusProcessorGetClusterInfo) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetClusterInfoArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getClusterInfo", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetClusterInfoResult{}
	var retval *ClusterSummary
	var err2 error
	if retval, err2 = p.handler.GetClusterInfo(); err2 != nil {
		switch v := err2.(type) {
		case *AuthorizationException:
			result.Aze = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getClusterInfo: "+err2.Error())
			oprot.WriteMessageBegin("getClusterInfo", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getClusterInfo", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type nimbusProcessorGetTopologyInfo struct {
	handler Nimbus
}

func (p *nimbusProcessorGetTopologyInfo) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetTopologyInfoArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getTopologyInfo", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetTopologyInfoResult{}
	var retval *TopologyInfo
	var err2 error
	if retval, err2 = p.handler.GetTopologyInfo(args.Id); err2 != nil {
		switch v := err2.(type) {
		case *NotAliveException:
			result.E = v
		case *AuthorizationException:
			result.Aze = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTopologyInfo: "+err2.Error())
			oprot.WriteMessageBegin("getTopologyInfo", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getTopologyInfo", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type nimbusProcessorGetTopologyConf struct {
	handler Nimbus
}

func (p *nimbusProcessorGetTopologyConf) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetTopologyConfArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getTopologyConf", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetTopologyConfResult{}
	var retval string
	var err2 error
	if retval, err2 = p.handler.GetTopologyConf(args.Id); err2 != nil {
		switch v := err2.(type) {
		case *NotAliveException:
			result.E = v
		case *AuthorizationException:
			result.Aze = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTopologyConf: "+err2.Error())
			oprot.WriteMessageBegin("getTopologyConf", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("getTopologyConf", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type nimbusProcessorGetTopology struct {
	handler Nimbus
}

func (p *nimbusProcessorGetTopology) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetTopologyArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getTopology", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetTopologyResult{}
	var retval *StormTopology
	var err2 error
	if retval, err2 = p.handler.GetTopology(args.Id); err2 != nil {
		switch v := err2.(type) {
		case *NotAliveException:
			result.E = v
		case *AuthorizationException:
			result.Aze = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTopology: "+err2.Error())
			oprot.WriteMessageBegin("getTopology", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getTopology", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type nimbusProcessorGetUserTopology struct {
	handler Nimbus
}

func (p *nimbusProcessorGetUserTopology) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetUserTopologyArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getUserTopology", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetUserTopologyResult{}
	var retval *StormTopology
	var err2 error
	if retval, err2 = p.handler.GetUserTopology(args.Id); err2 != nil {
		switch v := err2.(type) {
		case *NotAliveException:
			result.E = v
		case *AuthorizationException:
			result.Aze = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getUserTopology: "+err2.Error())
			oprot.WriteMessageBegin("getUserTopology", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getUserTopology", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

// HELPER FUNCTIONS AND STRUCTURES

type SubmitTopologyArgs struct {
	Name                string         `thrift:"name,1" json:"name"`
	UploadedJarLocation string         `thrift:"uploadedJarLocation,2" json:"uploadedJarLocation"`
	JsonConf            string         `thrift:"jsonConf,3" json:"jsonConf"`
	Topology            *StormTopology `thrift:"topology,4" json:"topology"`
}

func NewSubmitTopologyArgs() *SubmitTopologyArgs {
	return &SubmitTopologyArgs{}
}

func (p *SubmitTopologyArgs) GetName() string {
	return p.Name
}

func (p *SubmitTopologyArgs) GetUploadedJarLocation() string {
	return p.UploadedJarLocation
}

func (p *SubmitTopologyArgs) GetJsonConf() string {
	return p.JsonConf
}

var SubmitTopologyArgs_Topology_DEFAULT *StormTopology

func (p *SubmitTopologyArgs) GetTopology() *StormTopology {
	if !p.IsSetTopology() {
		return SubmitTopologyArgs_Topology_DEFAULT
	}
	return p.Topology
}
func (p *SubmitTopologyArgs) IsSetTopology() bool {
	return p.Topology != nil
}

func (p *SubmitTopologyArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SubmitTopologyArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *SubmitTopologyArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.UploadedJarLocation = v
	}
	return nil
}

func (p *SubmitTopologyArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.JsonConf = v
	}
	return nil
}

func (p *SubmitTopologyArgs) ReadField4(iprot thrift.TProtocol) error {
	p.Topology = &StormTopology{}
	if err := p.Topology.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Topology, err)
	}
	return nil
}

func (p *SubmitTopologyArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("submitTopology_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SubmitTopologyArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Name)); err != nil {
		return fmt.Errorf("%T.name (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:name: %s", p, err)
	}
	return err
}

func (p *SubmitTopologyArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("uploadedJarLocation", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:uploadedJarLocation: %s", p, err)
	}
	if err := oprot.WriteString(string(p.UploadedJarLocation)); err != nil {
		return fmt.Errorf("%T.uploadedJarLocation (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:uploadedJarLocation: %s", p, err)
	}
	return err
}

func (p *SubmitTopologyArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("jsonConf", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:jsonConf: %s", p, err)
	}
	if err := oprot.WriteString(string(p.JsonConf)); err != nil {
		return fmt.Errorf("%T.jsonConf (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:jsonConf: %s", p, err)
	}
	return err
}

func (p *SubmitTopologyArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("topology", thrift.STRUCT, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:topology: %s", p, err)
	}
	if err := p.Topology.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Topology, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:topology: %s", p, err)
	}
	return err
}

func (p *SubmitTopologyArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SubmitTopologyArgs(%+v)", *p)
}

type SubmitTopologyResult struct {
	E   *AlreadyAliveException    `thrift:"e,1" json:"e"`
	Ite *InvalidTopologyException `thrift:"ite,2" json:"ite"`
	Aze *AuthorizationException   `thrift:"aze,3" json:"aze"`
}

func NewSubmitTopologyResult() *SubmitTopologyResult {
	return &SubmitTopologyResult{}
}

var SubmitTopologyResult_E_DEFAULT *AlreadyAliveException

func (p *SubmitTopologyResult) GetE() *AlreadyAliveException {
	if !p.IsSetE() {
		return SubmitTopologyResult_E_DEFAULT
	}
	return p.E
}

var SubmitTopologyResult_Ite_DEFAULT *InvalidTopologyException

func (p *SubmitTopologyResult) GetIte() *InvalidTopologyException {
	if !p.IsSetIte() {
		return SubmitTopologyResult_Ite_DEFAULT
	}
	return p.Ite
}

var SubmitTopologyResult_Aze_DEFAULT *AuthorizationException

func (p *SubmitTopologyResult) GetAze() *AuthorizationException {
	if !p.IsSetAze() {
		return SubmitTopologyResult_Aze_DEFAULT
	}
	return p.Aze
}
func (p *SubmitTopologyResult) IsSetE() bool {
	return p.E != nil
}

func (p *SubmitTopologyResult) IsSetIte() bool {
	return p.Ite != nil
}

func (p *SubmitTopologyResult) IsSetAze() bool {
	return p.Aze != nil
}

func (p *SubmitTopologyResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SubmitTopologyResult) ReadField1(iprot thrift.TProtocol) error {
	p.E = &AlreadyAliveException{}
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E, err)
	}
	return nil
}

func (p *SubmitTopologyResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ite = &InvalidTopologyException{}
	if err := p.Ite.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ite, err)
	}
	return nil
}

func (p *SubmitTopologyResult) ReadField3(iprot thrift.TProtocol) error {
	p.Aze = &AuthorizationException{}
	if err := p.Aze.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Aze, err)
	}
	return nil
}

func (p *SubmitTopologyResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("submitTopology_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SubmitTopologyResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetE() {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *SubmitTopologyResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetIte() {
		if err := oprot.WriteFieldBegin("ite", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ite: %s", p, err)
		}
		if err := p.Ite.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ite, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ite: %s", p, err)
		}
	}
	return err
}

func (p *SubmitTopologyResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetAze() {
		if err := oprot.WriteFieldBegin("aze", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:aze: %s", p, err)
		}
		if err := p.Aze.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Aze, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:aze: %s", p, err)
		}
	}
	return err
}

func (p *SubmitTopologyResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SubmitTopologyResult(%+v)", *p)
}

type SubmitTopologyWithOptsArgs struct {
	Name                string         `thrift:"name,1" json:"name"`
	UploadedJarLocation string         `thrift:"uploadedJarLocation,2" json:"uploadedJarLocation"`
	JsonConf            string         `thrift:"jsonConf,3" json:"jsonConf"`
	Topology            *StormTopology `thrift:"topology,4" json:"topology"`
	Options             *SubmitOptions `thrift:"options,5" json:"options"`
}

func NewSubmitTopologyWithOptsArgs() *SubmitTopologyWithOptsArgs {
	return &SubmitTopologyWithOptsArgs{}
}

func (p *SubmitTopologyWithOptsArgs) GetName() string {
	return p.Name
}

func (p *SubmitTopologyWithOptsArgs) GetUploadedJarLocation() string {
	return p.UploadedJarLocation
}

func (p *SubmitTopologyWithOptsArgs) GetJsonConf() string {
	return p.JsonConf
}

var SubmitTopologyWithOptsArgs_Topology_DEFAULT *StormTopology

func (p *SubmitTopologyWithOptsArgs) GetTopology() *StormTopology {
	if !p.IsSetTopology() {
		return SubmitTopologyWithOptsArgs_Topology_DEFAULT
	}
	return p.Topology
}

var SubmitTopologyWithOptsArgs_Options_DEFAULT *SubmitOptions

func (p *SubmitTopologyWithOptsArgs) GetOptions() *SubmitOptions {
	if !p.IsSetOptions() {
		return SubmitTopologyWithOptsArgs_Options_DEFAULT
	}
	return p.Options
}
func (p *SubmitTopologyWithOptsArgs) IsSetTopology() bool {
	return p.Topology != nil
}

func (p *SubmitTopologyWithOptsArgs) IsSetOptions() bool {
	return p.Options != nil
}

func (p *SubmitTopologyWithOptsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.ReadField5(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SubmitTopologyWithOptsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *SubmitTopologyWithOptsArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.UploadedJarLocation = v
	}
	return nil
}

func (p *SubmitTopologyWithOptsArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.JsonConf = v
	}
	return nil
}

func (p *SubmitTopologyWithOptsArgs) ReadField4(iprot thrift.TProtocol) error {
	p.Topology = &StormTopology{}
	if err := p.Topology.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Topology, err)
	}
	return nil
}

func (p *SubmitTopologyWithOptsArgs) ReadField5(iprot thrift.TProtocol) error {
	p.Options = &SubmitOptions{}
	if err := p.Options.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Options, err)
	}
	return nil
}

func (p *SubmitTopologyWithOptsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("submitTopologyWithOpts_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SubmitTopologyWithOptsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Name)); err != nil {
		return fmt.Errorf("%T.name (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:name: %s", p, err)
	}
	return err
}

func (p *SubmitTopologyWithOptsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("uploadedJarLocation", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:uploadedJarLocation: %s", p, err)
	}
	if err := oprot.WriteString(string(p.UploadedJarLocation)); err != nil {
		return fmt.Errorf("%T.uploadedJarLocation (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:uploadedJarLocation: %s", p, err)
	}
	return err
}

func (p *SubmitTopologyWithOptsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("jsonConf", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:jsonConf: %s", p, err)
	}
	if err := oprot.WriteString(string(p.JsonConf)); err != nil {
		return fmt.Errorf("%T.jsonConf (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:jsonConf: %s", p, err)
	}
	return err
}

func (p *SubmitTopologyWithOptsArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("topology", thrift.STRUCT, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:topology: %s", p, err)
	}
	if err := p.Topology.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Topology, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:topology: %s", p, err)
	}
	return err
}

func (p *SubmitTopologyWithOptsArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("options", thrift.STRUCT, 5); err != nil {
		return fmt.Errorf("%T write field begin error 5:options: %s", p, err)
	}
	if err := p.Options.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Options, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 5:options: %s", p, err)
	}
	return err
}

func (p *SubmitTopologyWithOptsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SubmitTopologyWithOptsArgs(%+v)", *p)
}

type SubmitTopologyWithOptsResult struct {
	E   *AlreadyAliveException    `thrift:"e,1" json:"e"`
	Ite *InvalidTopologyException `thrift:"ite,2" json:"ite"`
	Aze *AuthorizationException   `thrift:"aze,3" json:"aze"`
}

func NewSubmitTopologyWithOptsResult() *SubmitTopologyWithOptsResult {
	return &SubmitTopologyWithOptsResult{}
}

var SubmitTopologyWithOptsResult_E_DEFAULT *AlreadyAliveException

func (p *SubmitTopologyWithOptsResult) GetE() *AlreadyAliveException {
	if !p.IsSetE() {
		return SubmitTopologyWithOptsResult_E_DEFAULT
	}
	return p.E
}

var SubmitTopologyWithOptsResult_Ite_DEFAULT *InvalidTopologyException

func (p *SubmitTopologyWithOptsResult) GetIte() *InvalidTopologyException {
	if !p.IsSetIte() {
		return SubmitTopologyWithOptsResult_Ite_DEFAULT
	}
	return p.Ite
}

var SubmitTopologyWithOptsResult_Aze_DEFAULT *AuthorizationException

func (p *SubmitTopologyWithOptsResult) GetAze() *AuthorizationException {
	if !p.IsSetAze() {
		return SubmitTopologyWithOptsResult_Aze_DEFAULT
	}
	return p.Aze
}
func (p *SubmitTopologyWithOptsResult) IsSetE() bool {
	return p.E != nil
}

func (p *SubmitTopologyWithOptsResult) IsSetIte() bool {
	return p.Ite != nil
}

func (p *SubmitTopologyWithOptsResult) IsSetAze() bool {
	return p.Aze != nil
}

func (p *SubmitTopologyWithOptsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SubmitTopologyWithOptsResult) ReadField1(iprot thrift.TProtocol) error {
	p.E = &AlreadyAliveException{}
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E, err)
	}
	return nil
}

func (p *SubmitTopologyWithOptsResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ite = &InvalidTopologyException{}
	if err := p.Ite.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ite, err)
	}
	return nil
}

func (p *SubmitTopologyWithOptsResult) ReadField3(iprot thrift.TProtocol) error {
	p.Aze = &AuthorizationException{}
	if err := p.Aze.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Aze, err)
	}
	return nil
}

func (p *SubmitTopologyWithOptsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("submitTopologyWithOpts_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SubmitTopologyWithOptsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetE() {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *SubmitTopologyWithOptsResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetIte() {
		if err := oprot.WriteFieldBegin("ite", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ite: %s", p, err)
		}
		if err := p.Ite.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ite, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ite: %s", p, err)
		}
	}
	return err
}

func (p *SubmitTopologyWithOptsResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetAze() {
		if err := oprot.WriteFieldBegin("aze", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:aze: %s", p, err)
		}
		if err := p.Aze.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Aze, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:aze: %s", p, err)
		}
	}
	return err
}

func (p *SubmitTopologyWithOptsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SubmitTopologyWithOptsResult(%+v)", *p)
}

type KillTopologyArgs struct {
	Name string `thrift:"name,1" json:"name"`
}

func NewKillTopologyArgs() *KillTopologyArgs {
	return &KillTopologyArgs{}
}

func (p *KillTopologyArgs) GetName() string {
	return p.Name
}
func (p *KillTopologyArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *KillTopologyArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *KillTopologyArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("killTopology_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *KillTopologyArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Name)); err != nil {
		return fmt.Errorf("%T.name (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:name: %s", p, err)
	}
	return err
}

func (p *KillTopologyArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("KillTopologyArgs(%+v)", *p)
}

type KillTopologyResult struct {
	E   *NotAliveException      `thrift:"e,1" json:"e"`
	Aze *AuthorizationException `thrift:"aze,2" json:"aze"`
}

func NewKillTopologyResult() *KillTopologyResult {
	return &KillTopologyResult{}
}

var KillTopologyResult_E_DEFAULT *NotAliveException

func (p *KillTopologyResult) GetE() *NotAliveException {
	if !p.IsSetE() {
		return KillTopologyResult_E_DEFAULT
	}
	return p.E
}

var KillTopologyResult_Aze_DEFAULT *AuthorizationException

func (p *KillTopologyResult) GetAze() *AuthorizationException {
	if !p.IsSetAze() {
		return KillTopologyResult_Aze_DEFAULT
	}
	return p.Aze
}
func (p *KillTopologyResult) IsSetE() bool {
	return p.E != nil
}

func (p *KillTopologyResult) IsSetAze() bool {
	return p.Aze != nil
}

func (p *KillTopologyResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *KillTopologyResult) ReadField1(iprot thrift.TProtocol) error {
	p.E = &NotAliveException{}
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E, err)
	}
	return nil
}

func (p *KillTopologyResult) ReadField2(iprot thrift.TProtocol) error {
	p.Aze = &AuthorizationException{}
	if err := p.Aze.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Aze, err)
	}
	return nil
}

func (p *KillTopologyResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("killTopology_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *KillTopologyResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetE() {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *KillTopologyResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetAze() {
		if err := oprot.WriteFieldBegin("aze", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:aze: %s", p, err)
		}
		if err := p.Aze.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Aze, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:aze: %s", p, err)
		}
	}
	return err
}

func (p *KillTopologyResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("KillTopologyResult(%+v)", *p)
}

type KillTopologyWithOptsArgs struct {
	Name    string       `thrift:"name,1" json:"name"`
	Options *KillOptions `thrift:"options,2" json:"options"`
}

func NewKillTopologyWithOptsArgs() *KillTopologyWithOptsArgs {
	return &KillTopologyWithOptsArgs{}
}

func (p *KillTopologyWithOptsArgs) GetName() string {
	return p.Name
}

var KillTopologyWithOptsArgs_Options_DEFAULT *KillOptions

func (p *KillTopologyWithOptsArgs) GetOptions() *KillOptions {
	if !p.IsSetOptions() {
		return KillTopologyWithOptsArgs_Options_DEFAULT
	}
	return p.Options
}
func (p *KillTopologyWithOptsArgs) IsSetOptions() bool {
	return p.Options != nil
}

func (p *KillTopologyWithOptsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *KillTopologyWithOptsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *KillTopologyWithOptsArgs) ReadField2(iprot thrift.TProtocol) error {
	p.Options = &KillOptions{}
	if err := p.Options.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Options, err)
	}
	return nil
}

func (p *KillTopologyWithOptsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("killTopologyWithOpts_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *KillTopologyWithOptsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Name)); err != nil {
		return fmt.Errorf("%T.name (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:name: %s", p, err)
	}
	return err
}

func (p *KillTopologyWithOptsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("options", thrift.STRUCT, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:options: %s", p, err)
	}
	if err := p.Options.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Options, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:options: %s", p, err)
	}
	return err
}

func (p *KillTopologyWithOptsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("KillTopologyWithOptsArgs(%+v)", *p)
}

type KillTopologyWithOptsResult struct {
	E   *NotAliveException      `thrift:"e,1" json:"e"`
	Aze *AuthorizationException `thrift:"aze,2" json:"aze"`
}

func NewKillTopologyWithOptsResult() *KillTopologyWithOptsResult {
	return &KillTopologyWithOptsResult{}
}

var KillTopologyWithOptsResult_E_DEFAULT *NotAliveException

func (p *KillTopologyWithOptsResult) GetE() *NotAliveException {
	if !p.IsSetE() {
		return KillTopologyWithOptsResult_E_DEFAULT
	}
	return p.E
}

var KillTopologyWithOptsResult_Aze_DEFAULT *AuthorizationException

func (p *KillTopologyWithOptsResult) GetAze() *AuthorizationException {
	if !p.IsSetAze() {
		return KillTopologyWithOptsResult_Aze_DEFAULT
	}
	return p.Aze
}
func (p *KillTopologyWithOptsResult) IsSetE() bool {
	return p.E != nil
}

func (p *KillTopologyWithOptsResult) IsSetAze() bool {
	return p.Aze != nil
}

func (p *KillTopologyWithOptsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *KillTopologyWithOptsResult) ReadField1(iprot thrift.TProtocol) error {
	p.E = &NotAliveException{}
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E, err)
	}
	return nil
}

func (p *KillTopologyWithOptsResult) ReadField2(iprot thrift.TProtocol) error {
	p.Aze = &AuthorizationException{}
	if err := p.Aze.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Aze, err)
	}
	return nil
}

func (p *KillTopologyWithOptsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("killTopologyWithOpts_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *KillTopologyWithOptsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetE() {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *KillTopologyWithOptsResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetAze() {
		if err := oprot.WriteFieldBegin("aze", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:aze: %s", p, err)
		}
		if err := p.Aze.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Aze, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:aze: %s", p, err)
		}
	}
	return err
}

func (p *KillTopologyWithOptsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("KillTopologyWithOptsResult(%+v)", *p)
}

type ActivateArgs struct {
	Name string `thrift:"name,1" json:"name"`
}

func NewActivateArgs() *ActivateArgs {
	return &ActivateArgs{}
}

func (p *ActivateArgs) GetName() string {
	return p.Name
}
func (p *ActivateArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ActivateArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *ActivateArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("activate_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ActivateArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Name)); err != nil {
		return fmt.Errorf("%T.name (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:name: %s", p, err)
	}
	return err
}

func (p *ActivateArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ActivateArgs(%+v)", *p)
}

type ActivateResult struct {
	E   *NotAliveException      `thrift:"e,1" json:"e"`
	Aze *AuthorizationException `thrift:"aze,2" json:"aze"`
}

func NewActivateResult() *ActivateResult {
	return &ActivateResult{}
}

var ActivateResult_E_DEFAULT *NotAliveException

func (p *ActivateResult) GetE() *NotAliveException {
	if !p.IsSetE() {
		return ActivateResult_E_DEFAULT
	}
	return p.E
}

var ActivateResult_Aze_DEFAULT *AuthorizationException

func (p *ActivateResult) GetAze() *AuthorizationException {
	if !p.IsSetAze() {
		return ActivateResult_Aze_DEFAULT
	}
	return p.Aze
}
func (p *ActivateResult) IsSetE() bool {
	return p.E != nil
}

func (p *ActivateResult) IsSetAze() bool {
	return p.Aze != nil
}

func (p *ActivateResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ActivateResult) ReadField1(iprot thrift.TProtocol) error {
	p.E = &NotAliveException{}
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E, err)
	}
	return nil
}

func (p *ActivateResult) ReadField2(iprot thrift.TProtocol) error {
	p.Aze = &AuthorizationException{}
	if err := p.Aze.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Aze, err)
	}
	return nil
}

func (p *ActivateResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("activate_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ActivateResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetE() {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *ActivateResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetAze() {
		if err := oprot.WriteFieldBegin("aze", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:aze: %s", p, err)
		}
		if err := p.Aze.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Aze, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:aze: %s", p, err)
		}
	}
	return err
}

func (p *ActivateResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ActivateResult(%+v)", *p)
}

type DeactivateArgs struct {
	Name string `thrift:"name,1" json:"name"`
}

func NewDeactivateArgs() *DeactivateArgs {
	return &DeactivateArgs{}
}

func (p *DeactivateArgs) GetName() string {
	return p.Name
}
func (p *DeactivateArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeactivateArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *DeactivateArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deactivate_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DeactivateArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Name)); err != nil {
		return fmt.Errorf("%T.name (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:name: %s", p, err)
	}
	return err
}

func (p *DeactivateArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeactivateArgs(%+v)", *p)
}

type DeactivateResult struct {
	E   *NotAliveException      `thrift:"e,1" json:"e"`
	Aze *AuthorizationException `thrift:"aze,2" json:"aze"`
}

func NewDeactivateResult() *DeactivateResult {
	return &DeactivateResult{}
}

var DeactivateResult_E_DEFAULT *NotAliveException

func (p *DeactivateResult) GetE() *NotAliveException {
	if !p.IsSetE() {
		return DeactivateResult_E_DEFAULT
	}
	return p.E
}

var DeactivateResult_Aze_DEFAULT *AuthorizationException

func (p *DeactivateResult) GetAze() *AuthorizationException {
	if !p.IsSetAze() {
		return DeactivateResult_Aze_DEFAULT
	}
	return p.Aze
}
func (p *DeactivateResult) IsSetE() bool {
	return p.E != nil
}

func (p *DeactivateResult) IsSetAze() bool {
	return p.Aze != nil
}

func (p *DeactivateResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeactivateResult) ReadField1(iprot thrift.TProtocol) error {
	p.E = &NotAliveException{}
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E, err)
	}
	return nil
}

func (p *DeactivateResult) ReadField2(iprot thrift.TProtocol) error {
	p.Aze = &AuthorizationException{}
	if err := p.Aze.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Aze, err)
	}
	return nil
}

func (p *DeactivateResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deactivate_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DeactivateResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetE() {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *DeactivateResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetAze() {
		if err := oprot.WriteFieldBegin("aze", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:aze: %s", p, err)
		}
		if err := p.Aze.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Aze, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:aze: %s", p, err)
		}
	}
	return err
}

func (p *DeactivateResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeactivateResult(%+v)", *p)
}

type RebalanceArgs struct {
	Name    string            `thrift:"name,1" json:"name"`
	Options *RebalanceOptions `thrift:"options,2" json:"options"`
}

func NewRebalanceArgs() *RebalanceArgs {
	return &RebalanceArgs{}
}

func (p *RebalanceArgs) GetName() string {
	return p.Name
}

var RebalanceArgs_Options_DEFAULT *RebalanceOptions

func (p *RebalanceArgs) GetOptions() *RebalanceOptions {
	if !p.IsSetOptions() {
		return RebalanceArgs_Options_DEFAULT
	}
	return p.Options
}
func (p *RebalanceArgs) IsSetOptions() bool {
	return p.Options != nil
}

func (p *RebalanceArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *RebalanceArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *RebalanceArgs) ReadField2(iprot thrift.TProtocol) error {
	p.Options = &RebalanceOptions{}
	if err := p.Options.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Options, err)
	}
	return nil
}

func (p *RebalanceArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("rebalance_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *RebalanceArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Name)); err != nil {
		return fmt.Errorf("%T.name (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:name: %s", p, err)
	}
	return err
}

func (p *RebalanceArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("options", thrift.STRUCT, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:options: %s", p, err)
	}
	if err := p.Options.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Options, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:options: %s", p, err)
	}
	return err
}

func (p *RebalanceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RebalanceArgs(%+v)", *p)
}

type RebalanceResult struct {
	E   *NotAliveException        `thrift:"e,1" json:"e"`
	Ite *InvalidTopologyException `thrift:"ite,2" json:"ite"`
	Aze *AuthorizationException   `thrift:"aze,3" json:"aze"`
}

func NewRebalanceResult() *RebalanceResult {
	return &RebalanceResult{}
}

var RebalanceResult_E_DEFAULT *NotAliveException

func (p *RebalanceResult) GetE() *NotAliveException {
	if !p.IsSetE() {
		return RebalanceResult_E_DEFAULT
	}
	return p.E
}

var RebalanceResult_Ite_DEFAULT *InvalidTopologyException

func (p *RebalanceResult) GetIte() *InvalidTopologyException {
	if !p.IsSetIte() {
		return RebalanceResult_Ite_DEFAULT
	}
	return p.Ite
}

var RebalanceResult_Aze_DEFAULT *AuthorizationException

func (p *RebalanceResult) GetAze() *AuthorizationException {
	if !p.IsSetAze() {
		return RebalanceResult_Aze_DEFAULT
	}
	return p.Aze
}
func (p *RebalanceResult) IsSetE() bool {
	return p.E != nil
}

func (p *RebalanceResult) IsSetIte() bool {
	return p.Ite != nil
}

func (p *RebalanceResult) IsSetAze() bool {
	return p.Aze != nil
}

func (p *RebalanceResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *RebalanceResult) ReadField1(iprot thrift.TProtocol) error {
	p.E = &NotAliveException{}
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E, err)
	}
	return nil
}

func (p *RebalanceResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ite = &InvalidTopologyException{}
	if err := p.Ite.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ite, err)
	}
	return nil
}

func (p *RebalanceResult) ReadField3(iprot thrift.TProtocol) error {
	p.Aze = &AuthorizationException{}
	if err := p.Aze.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Aze, err)
	}
	return nil
}

func (p *RebalanceResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("rebalance_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *RebalanceResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetE() {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *RebalanceResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetIte() {
		if err := oprot.WriteFieldBegin("ite", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ite: %s", p, err)
		}
		if err := p.Ite.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ite, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ite: %s", p, err)
		}
	}
	return err
}

func (p *RebalanceResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetAze() {
		if err := oprot.WriteFieldBegin("aze", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:aze: %s", p, err)
		}
		if err := p.Aze.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Aze, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:aze: %s", p, err)
		}
	}
	return err
}

func (p *RebalanceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RebalanceResult(%+v)", *p)
}

type UploadNewCredentialsArgs struct {
	Name  string       `thrift:"name,1" json:"name"`
	Creds *Credentials `thrift:"creds,2" json:"creds"`
}

func NewUploadNewCredentialsArgs() *UploadNewCredentialsArgs {
	return &UploadNewCredentialsArgs{}
}

func (p *UploadNewCredentialsArgs) GetName() string {
	return p.Name
}

var UploadNewCredentialsArgs_Creds_DEFAULT *Credentials

func (p *UploadNewCredentialsArgs) GetCreds() *Credentials {
	if !p.IsSetCreds() {
		return UploadNewCredentialsArgs_Creds_DEFAULT
	}
	return p.Creds
}
func (p *UploadNewCredentialsArgs) IsSetCreds() bool {
	return p.Creds != nil
}

func (p *UploadNewCredentialsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *UploadNewCredentialsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *UploadNewCredentialsArgs) ReadField2(iprot thrift.TProtocol) error {
	p.Creds = &Credentials{}
	if err := p.Creds.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Creds, err)
	}
	return nil
}

func (p *UploadNewCredentialsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("uploadNewCredentials_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *UploadNewCredentialsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Name)); err != nil {
		return fmt.Errorf("%T.name (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:name: %s", p, err)
	}
	return err
}

func (p *UploadNewCredentialsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("creds", thrift.STRUCT, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:creds: %s", p, err)
	}
	if err := p.Creds.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Creds, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:creds: %s", p, err)
	}
	return err
}

func (p *UploadNewCredentialsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UploadNewCredentialsArgs(%+v)", *p)
}

type UploadNewCredentialsResult struct {
	E   *NotAliveException        `thrift:"e,1" json:"e"`
	Ite *InvalidTopologyException `thrift:"ite,2" json:"ite"`
	Aze *AuthorizationException   `thrift:"aze,3" json:"aze"`
}

func NewUploadNewCredentialsResult() *UploadNewCredentialsResult {
	return &UploadNewCredentialsResult{}
}

var UploadNewCredentialsResult_E_DEFAULT *NotAliveException

func (p *UploadNewCredentialsResult) GetE() *NotAliveException {
	if !p.IsSetE() {
		return UploadNewCredentialsResult_E_DEFAULT
	}
	return p.E
}

var UploadNewCredentialsResult_Ite_DEFAULT *InvalidTopologyException

func (p *UploadNewCredentialsResult) GetIte() *InvalidTopologyException {
	if !p.IsSetIte() {
		return UploadNewCredentialsResult_Ite_DEFAULT
	}
	return p.Ite
}

var UploadNewCredentialsResult_Aze_DEFAULT *AuthorizationException

func (p *UploadNewCredentialsResult) GetAze() *AuthorizationException {
	if !p.IsSetAze() {
		return UploadNewCredentialsResult_Aze_DEFAULT
	}
	return p.Aze
}
func (p *UploadNewCredentialsResult) IsSetE() bool {
	return p.E != nil
}

func (p *UploadNewCredentialsResult) IsSetIte() bool {
	return p.Ite != nil
}

func (p *UploadNewCredentialsResult) IsSetAze() bool {
	return p.Aze != nil
}

func (p *UploadNewCredentialsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *UploadNewCredentialsResult) ReadField1(iprot thrift.TProtocol) error {
	p.E = &NotAliveException{}
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E, err)
	}
	return nil
}

func (p *UploadNewCredentialsResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ite = &InvalidTopologyException{}
	if err := p.Ite.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ite, err)
	}
	return nil
}

func (p *UploadNewCredentialsResult) ReadField3(iprot thrift.TProtocol) error {
	p.Aze = &AuthorizationException{}
	if err := p.Aze.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Aze, err)
	}
	return nil
}

func (p *UploadNewCredentialsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("uploadNewCredentials_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *UploadNewCredentialsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetE() {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *UploadNewCredentialsResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetIte() {
		if err := oprot.WriteFieldBegin("ite", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ite: %s", p, err)
		}
		if err := p.Ite.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ite, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ite: %s", p, err)
		}
	}
	return err
}

func (p *UploadNewCredentialsResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetAze() {
		if err := oprot.WriteFieldBegin("aze", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:aze: %s", p, err)
		}
		if err := p.Aze.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Aze, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:aze: %s", p, err)
		}
	}
	return err
}

func (p *UploadNewCredentialsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UploadNewCredentialsResult(%+v)", *p)
}

type BeginFileUploadArgs struct {
}

func NewBeginFileUploadArgs() *BeginFileUploadArgs {
	return &BeginFileUploadArgs{}
}

func (p *BeginFileUploadArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *BeginFileUploadArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("beginFileUpload_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *BeginFileUploadArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("BeginFileUploadArgs(%+v)", *p)
}

type BeginFileUploadResult struct {
	Success *string                 `thrift:"success,0" json:"success"`
	Aze     *AuthorizationException `thrift:"aze,1" json:"aze"`
}

func NewBeginFileUploadResult() *BeginFileUploadResult {
	return &BeginFileUploadResult{}
}

var BeginFileUploadResult_Success_DEFAULT string

func (p *BeginFileUploadResult) GetSuccess() string {
	if !p.IsSetSuccess() {
		return BeginFileUploadResult_Success_DEFAULT
	}
	return *p.Success
}

var BeginFileUploadResult_Aze_DEFAULT *AuthorizationException

func (p *BeginFileUploadResult) GetAze() *AuthorizationException {
	if !p.IsSetAze() {
		return BeginFileUploadResult_Aze_DEFAULT
	}
	return p.Aze
}
func (p *BeginFileUploadResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *BeginFileUploadResult) IsSetAze() bool {
	return p.Aze != nil
}

func (p *BeginFileUploadResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *BeginFileUploadResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *BeginFileUploadResult) ReadField1(iprot thrift.TProtocol) error {
	p.Aze = &AuthorizationException{}
	if err := p.Aze.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Aze, err)
	}
	return nil
}

func (p *BeginFileUploadResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("beginFileUpload_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *BeginFileUploadResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteString(string(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *BeginFileUploadResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetAze() {
		if err := oprot.WriteFieldBegin("aze", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:aze: %s", p, err)
		}
		if err := p.Aze.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Aze, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:aze: %s", p, err)
		}
	}
	return err
}

func (p *BeginFileUploadResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("BeginFileUploadResult(%+v)", *p)
}

type UploadChunkArgs struct {
	Location string `thrift:"location,1" json:"location"`
	Chunk    []byte `thrift:"chunk,2" json:"chunk"`
}

func NewUploadChunkArgs() *UploadChunkArgs {
	return &UploadChunkArgs{}
}

func (p *UploadChunkArgs) GetLocation() string {
	return p.Location
}

func (p *UploadChunkArgs) GetChunk() []byte {
	return p.Chunk
}
func (p *UploadChunkArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *UploadChunkArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Location = v
	}
	return nil
}

func (p *UploadChunkArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.Chunk = v
	}
	return nil
}

func (p *UploadChunkArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("uploadChunk_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *UploadChunkArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("location", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:location: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Location)); err != nil {
		return fmt.Errorf("%T.location (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:location: %s", p, err)
	}
	return err
}

func (p *UploadChunkArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("chunk", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:chunk: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Chunk); err != nil {
		return fmt.Errorf("%T.chunk (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:chunk: %s", p, err)
	}
	return err
}

func (p *UploadChunkArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UploadChunkArgs(%+v)", *p)
}

type UploadChunkResult struct {
	Aze *AuthorizationException `thrift:"aze,1" json:"aze"`
}

func NewUploadChunkResult() *UploadChunkResult {
	return &UploadChunkResult{}
}

var UploadChunkResult_Aze_DEFAULT *AuthorizationException

func (p *UploadChunkResult) GetAze() *AuthorizationException {
	if !p.IsSetAze() {
		return UploadChunkResult_Aze_DEFAULT
	}
	return p.Aze
}
func (p *UploadChunkResult) IsSetAze() bool {
	return p.Aze != nil
}

func (p *UploadChunkResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *UploadChunkResult) ReadField1(iprot thrift.TProtocol) error {
	p.Aze = &AuthorizationException{}
	if err := p.Aze.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Aze, err)
	}
	return nil
}

func (p *UploadChunkResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("uploadChunk_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *UploadChunkResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetAze() {
		if err := oprot.WriteFieldBegin("aze", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:aze: %s", p, err)
		}
		if err := p.Aze.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Aze, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:aze: %s", p, err)
		}
	}
	return err
}

func (p *UploadChunkResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UploadChunkResult(%+v)", *p)
}

type FinishFileUploadArgs struct {
	Location string `thrift:"location,1" json:"location"`
}

func NewFinishFileUploadArgs() *FinishFileUploadArgs {
	return &FinishFileUploadArgs{}
}

func (p *FinishFileUploadArgs) GetLocation() string {
	return p.Location
}
func (p *FinishFileUploadArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *FinishFileUploadArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Location = v
	}
	return nil
}

func (p *FinishFileUploadArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("finishFileUpload_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *FinishFileUploadArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("location", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:location: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Location)); err != nil {
		return fmt.Errorf("%T.location (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:location: %s", p, err)
	}
	return err
}

func (p *FinishFileUploadArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FinishFileUploadArgs(%+v)", *p)
}

type FinishFileUploadResult struct {
	Aze *AuthorizationException `thrift:"aze,1" json:"aze"`
}

func NewFinishFileUploadResult() *FinishFileUploadResult {
	return &FinishFileUploadResult{}
}

var FinishFileUploadResult_Aze_DEFAULT *AuthorizationException

func (p *FinishFileUploadResult) GetAze() *AuthorizationException {
	if !p.IsSetAze() {
		return FinishFileUploadResult_Aze_DEFAULT
	}
	return p.Aze
}
func (p *FinishFileUploadResult) IsSetAze() bool {
	return p.Aze != nil
}

func (p *FinishFileUploadResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *FinishFileUploadResult) ReadField1(iprot thrift.TProtocol) error {
	p.Aze = &AuthorizationException{}
	if err := p.Aze.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Aze, err)
	}
	return nil
}

func (p *FinishFileUploadResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("finishFileUpload_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *FinishFileUploadResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetAze() {
		if err := oprot.WriteFieldBegin("aze", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:aze: %s", p, err)
		}
		if err := p.Aze.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Aze, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:aze: %s", p, err)
		}
	}
	return err
}

func (p *FinishFileUploadResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FinishFileUploadResult(%+v)", *p)
}

type BeginFileDownloadArgs struct {
	File string `thrift:"file,1" json:"file"`
}

func NewBeginFileDownloadArgs() *BeginFileDownloadArgs {
	return &BeginFileDownloadArgs{}
}

func (p *BeginFileDownloadArgs) GetFile() string {
	return p.File
}
func (p *BeginFileDownloadArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *BeginFileDownloadArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.File = v
	}
	return nil
}

func (p *BeginFileDownloadArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("beginFileDownload_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *BeginFileDownloadArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("file", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:file: %s", p, err)
	}
	if err := oprot.WriteString(string(p.File)); err != nil {
		return fmt.Errorf("%T.file (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:file: %s", p, err)
	}
	return err
}

func (p *BeginFileDownloadArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("BeginFileDownloadArgs(%+v)", *p)
}

type BeginFileDownloadResult struct {
	Success *string                 `thrift:"success,0" json:"success"`
	Aze     *AuthorizationException `thrift:"aze,1" json:"aze"`
}

func NewBeginFileDownloadResult() *BeginFileDownloadResult {
	return &BeginFileDownloadResult{}
}

var BeginFileDownloadResult_Success_DEFAULT string

func (p *BeginFileDownloadResult) GetSuccess() string {
	if !p.IsSetSuccess() {
		return BeginFileDownloadResult_Success_DEFAULT
	}
	return *p.Success
}

var BeginFileDownloadResult_Aze_DEFAULT *AuthorizationException

func (p *BeginFileDownloadResult) GetAze() *AuthorizationException {
	if !p.IsSetAze() {
		return BeginFileDownloadResult_Aze_DEFAULT
	}
	return p.Aze
}
func (p *BeginFileDownloadResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *BeginFileDownloadResult) IsSetAze() bool {
	return p.Aze != nil
}

func (p *BeginFileDownloadResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *BeginFileDownloadResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *BeginFileDownloadResult) ReadField1(iprot thrift.TProtocol) error {
	p.Aze = &AuthorizationException{}
	if err := p.Aze.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Aze, err)
	}
	return nil
}

func (p *BeginFileDownloadResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("beginFileDownload_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *BeginFileDownloadResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteString(string(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *BeginFileDownloadResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetAze() {
		if err := oprot.WriteFieldBegin("aze", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:aze: %s", p, err)
		}
		if err := p.Aze.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Aze, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:aze: %s", p, err)
		}
	}
	return err
}

func (p *BeginFileDownloadResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("BeginFileDownloadResult(%+v)", *p)
}

type DownloadChunkArgs struct {
	Id string `thrift:"id,1" json:"id"`
}

func NewDownloadChunkArgs() *DownloadChunkArgs {
	return &DownloadChunkArgs{}
}

func (p *DownloadChunkArgs) GetId() string {
	return p.Id
}
func (p *DownloadChunkArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DownloadChunkArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Id = v
	}
	return nil
}

func (p *DownloadChunkArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("downloadChunk_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DownloadChunkArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("id", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:id: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Id)); err != nil {
		return fmt.Errorf("%T.id (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:id: %s", p, err)
	}
	return err
}

func (p *DownloadChunkArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DownloadChunkArgs(%+v)", *p)
}

type DownloadChunkResult struct {
	Success []byte                  `thrift:"success,0" json:"success"`
	Aze     *AuthorizationException `thrift:"aze,1" json:"aze"`
}

func NewDownloadChunkResult() *DownloadChunkResult {
	return &DownloadChunkResult{}
}

var DownloadChunkResult_Success_DEFAULT []byte

func (p *DownloadChunkResult) GetSuccess() []byte {
	return p.Success
}

var DownloadChunkResult_Aze_DEFAULT *AuthorizationException

func (p *DownloadChunkResult) GetAze() *AuthorizationException {
	if !p.IsSetAze() {
		return DownloadChunkResult_Aze_DEFAULT
	}
	return p.Aze
}
func (p *DownloadChunkResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DownloadChunkResult) IsSetAze() bool {
	return p.Aze != nil
}

func (p *DownloadChunkResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DownloadChunkResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = v
	}
	return nil
}

func (p *DownloadChunkResult) ReadField1(iprot thrift.TProtocol) error {
	p.Aze = &AuthorizationException{}
	if err := p.Aze.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Aze, err)
	}
	return nil
}

func (p *DownloadChunkResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("downloadChunk_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DownloadChunkResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Success); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *DownloadChunkResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetAze() {
		if err := oprot.WriteFieldBegin("aze", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:aze: %s", p, err)
		}
		if err := p.Aze.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Aze, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:aze: %s", p, err)
		}
	}
	return err
}

func (p *DownloadChunkResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DownloadChunkResult(%+v)", *p)
}

type GetNimbusConfArgs struct {
}

func NewGetNimbusConfArgs() *GetNimbusConfArgs {
	return &GetNimbusConfArgs{}
}

func (p *GetNimbusConfArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetNimbusConfArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getNimbusConf_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetNimbusConfArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetNimbusConfArgs(%+v)", *p)
}

type GetNimbusConfResult struct {
	Success *string                 `thrift:"success,0" json:"success"`
	Aze     *AuthorizationException `thrift:"aze,1" json:"aze"`
}

func NewGetNimbusConfResult() *GetNimbusConfResult {
	return &GetNimbusConfResult{}
}

var GetNimbusConfResult_Success_DEFAULT string

func (p *GetNimbusConfResult) GetSuccess() string {
	if !p.IsSetSuccess() {
		return GetNimbusConfResult_Success_DEFAULT
	}
	return *p.Success
}

var GetNimbusConfResult_Aze_DEFAULT *AuthorizationException

func (p *GetNimbusConfResult) GetAze() *AuthorizationException {
	if !p.IsSetAze() {
		return GetNimbusConfResult_Aze_DEFAULT
	}
	return p.Aze
}
func (p *GetNimbusConfResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetNimbusConfResult) IsSetAze() bool {
	return p.Aze != nil
}

func (p *GetNimbusConfResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetNimbusConfResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *GetNimbusConfResult) ReadField1(iprot thrift.TProtocol) error {
	p.Aze = &AuthorizationException{}
	if err := p.Aze.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Aze, err)
	}
	return nil
}

func (p *GetNimbusConfResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getNimbusConf_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetNimbusConfResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteString(string(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetNimbusConfResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetAze() {
		if err := oprot.WriteFieldBegin("aze", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:aze: %s", p, err)
		}
		if err := p.Aze.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Aze, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:aze: %s", p, err)
		}
	}
	return err
}

func (p *GetNimbusConfResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetNimbusConfResult(%+v)", *p)
}

type GetClusterInfoArgs struct {
}

func NewGetClusterInfoArgs() *GetClusterInfoArgs {
	return &GetClusterInfoArgs{}
}

func (p *GetClusterInfoArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetClusterInfoArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getClusterInfo_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetClusterInfoArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetClusterInfoArgs(%+v)", *p)
}

type GetClusterInfoResult struct {
	Success *ClusterSummary         `thrift:"success,0" json:"success"`
	Aze     *AuthorizationException `thrift:"aze,1" json:"aze"`
}

func NewGetClusterInfoResult() *GetClusterInfoResult {
	return &GetClusterInfoResult{}
}

var GetClusterInfoResult_Success_DEFAULT *ClusterSummary

func (p *GetClusterInfoResult) GetSuccess() *ClusterSummary {
	if !p.IsSetSuccess() {
		return GetClusterInfoResult_Success_DEFAULT
	}
	return p.Success
}

var GetClusterInfoResult_Aze_DEFAULT *AuthorizationException

func (p *GetClusterInfoResult) GetAze() *AuthorizationException {
	if !p.IsSetAze() {
		return GetClusterInfoResult_Aze_DEFAULT
	}
	return p.Aze
}
func (p *GetClusterInfoResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetClusterInfoResult) IsSetAze() bool {
	return p.Aze != nil
}

func (p *GetClusterInfoResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetClusterInfoResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &ClusterSummary{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *GetClusterInfoResult) ReadField1(iprot thrift.TProtocol) error {
	p.Aze = &AuthorizationException{}
	if err := p.Aze.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Aze, err)
	}
	return nil
}

func (p *GetClusterInfoResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getClusterInfo_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetClusterInfoResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetClusterInfoResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetAze() {
		if err := oprot.WriteFieldBegin("aze", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:aze: %s", p, err)
		}
		if err := p.Aze.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Aze, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:aze: %s", p, err)
		}
	}
	return err
}

func (p *GetClusterInfoResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetClusterInfoResult(%+v)", *p)
}

type GetTopologyInfoArgs struct {
	Id string `thrift:"id,1" json:"id"`
}

func NewGetTopologyInfoArgs() *GetTopologyInfoArgs {
	return &GetTopologyInfoArgs{}
}

func (p *GetTopologyInfoArgs) GetId() string {
	return p.Id
}
func (p *GetTopologyInfoArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTopologyInfoArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Id = v
	}
	return nil
}

func (p *GetTopologyInfoArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTopologyInfo_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTopologyInfoArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("id", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:id: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Id)); err != nil {
		return fmt.Errorf("%T.id (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:id: %s", p, err)
	}
	return err
}

func (p *GetTopologyInfoArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTopologyInfoArgs(%+v)", *p)
}

type GetTopologyInfoResult struct {
	Success *TopologyInfo           `thrift:"success,0" json:"success"`
	E       *NotAliveException      `thrift:"e,1" json:"e"`
	Aze     *AuthorizationException `thrift:"aze,2" json:"aze"`
}

func NewGetTopologyInfoResult() *GetTopologyInfoResult {
	return &GetTopologyInfoResult{}
}

var GetTopologyInfoResult_Success_DEFAULT *TopologyInfo

func (p *GetTopologyInfoResult) GetSuccess() *TopologyInfo {
	if !p.IsSetSuccess() {
		return GetTopologyInfoResult_Success_DEFAULT
	}
	return p.Success
}

var GetTopologyInfoResult_E_DEFAULT *NotAliveException

func (p *GetTopologyInfoResult) GetE() *NotAliveException {
	if !p.IsSetE() {
		return GetTopologyInfoResult_E_DEFAULT
	}
	return p.E
}

var GetTopologyInfoResult_Aze_DEFAULT *AuthorizationException

func (p *GetTopologyInfoResult) GetAze() *AuthorizationException {
	if !p.IsSetAze() {
		return GetTopologyInfoResult_Aze_DEFAULT
	}
	return p.Aze
}
func (p *GetTopologyInfoResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetTopologyInfoResult) IsSetE() bool {
	return p.E != nil
}

func (p *GetTopologyInfoResult) IsSetAze() bool {
	return p.Aze != nil
}

func (p *GetTopologyInfoResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTopologyInfoResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &TopologyInfo{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *GetTopologyInfoResult) ReadField1(iprot thrift.TProtocol) error {
	p.E = &NotAliveException{}
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E, err)
	}
	return nil
}

func (p *GetTopologyInfoResult) ReadField2(iprot thrift.TProtocol) error {
	p.Aze = &AuthorizationException{}
	if err := p.Aze.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Aze, err)
	}
	return nil
}

func (p *GetTopologyInfoResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTopologyInfo_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTopologyInfoResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetTopologyInfoResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetE() {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *GetTopologyInfoResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetAze() {
		if err := oprot.WriteFieldBegin("aze", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:aze: %s", p, err)
		}
		if err := p.Aze.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Aze, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:aze: %s", p, err)
		}
	}
	return err
}

func (p *GetTopologyInfoResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTopologyInfoResult(%+v)", *p)
}

type GetTopologyConfArgs struct {
	Id string `thrift:"id,1" json:"id"`
}

func NewGetTopologyConfArgs() *GetTopologyConfArgs {
	return &GetTopologyConfArgs{}
}

func (p *GetTopologyConfArgs) GetId() string {
	return p.Id
}
func (p *GetTopologyConfArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTopologyConfArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Id = v
	}
	return nil
}

func (p *GetTopologyConfArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTopologyConf_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTopologyConfArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("id", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:id: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Id)); err != nil {
		return fmt.Errorf("%T.id (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:id: %s", p, err)
	}
	return err
}

func (p *GetTopologyConfArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTopologyConfArgs(%+v)", *p)
}

type GetTopologyConfResult struct {
	Success *string                 `thrift:"success,0" json:"success"`
	E       *NotAliveException      `thrift:"e,1" json:"e"`
	Aze     *AuthorizationException `thrift:"aze,2" json:"aze"`
}

func NewGetTopologyConfResult() *GetTopologyConfResult {
	return &GetTopologyConfResult{}
}

var GetTopologyConfResult_Success_DEFAULT string

func (p *GetTopologyConfResult) GetSuccess() string {
	if !p.IsSetSuccess() {
		return GetTopologyConfResult_Success_DEFAULT
	}
	return *p.Success
}

var GetTopologyConfResult_E_DEFAULT *NotAliveException

func (p *GetTopologyConfResult) GetE() *NotAliveException {
	if !p.IsSetE() {
		return GetTopologyConfResult_E_DEFAULT
	}
	return p.E
}

var GetTopologyConfResult_Aze_DEFAULT *AuthorizationException

func (p *GetTopologyConfResult) GetAze() *AuthorizationException {
	if !p.IsSetAze() {
		return GetTopologyConfResult_Aze_DEFAULT
	}
	return p.Aze
}
func (p *GetTopologyConfResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetTopologyConfResult) IsSetE() bool {
	return p.E != nil
}

func (p *GetTopologyConfResult) IsSetAze() bool {
	return p.Aze != nil
}

func (p *GetTopologyConfResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTopologyConfResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *GetTopologyConfResult) ReadField1(iprot thrift.TProtocol) error {
	p.E = &NotAliveException{}
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E, err)
	}
	return nil
}

func (p *GetTopologyConfResult) ReadField2(iprot thrift.TProtocol) error {
	p.Aze = &AuthorizationException{}
	if err := p.Aze.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Aze, err)
	}
	return nil
}

func (p *GetTopologyConfResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTopologyConf_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTopologyConfResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteString(string(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetTopologyConfResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetE() {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *GetTopologyConfResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetAze() {
		if err := oprot.WriteFieldBegin("aze", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:aze: %s", p, err)
		}
		if err := p.Aze.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Aze, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:aze: %s", p, err)
		}
	}
	return err
}

func (p *GetTopologyConfResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTopologyConfResult(%+v)", *p)
}

type GetTopologyArgs struct {
	Id string `thrift:"id,1" json:"id"`
}

func NewGetTopologyArgs() *GetTopologyArgs {
	return &GetTopologyArgs{}
}

func (p *GetTopologyArgs) GetId() string {
	return p.Id
}
func (p *GetTopologyArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTopologyArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Id = v
	}
	return nil
}

func (p *GetTopologyArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTopology_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTopologyArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("id", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:id: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Id)); err != nil {
		return fmt.Errorf("%T.id (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:id: %s", p, err)
	}
	return err
}

func (p *GetTopologyArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTopologyArgs(%+v)", *p)
}

type GetTopologyResult struct {
	Success *StormTopology          `thrift:"success,0" json:"success"`
	E       *NotAliveException      `thrift:"e,1" json:"e"`
	Aze     *AuthorizationException `thrift:"aze,2" json:"aze"`
}

func NewGetTopologyResult() *GetTopologyResult {
	return &GetTopologyResult{}
}

var GetTopologyResult_Success_DEFAULT *StormTopology

func (p *GetTopologyResult) GetSuccess() *StormTopology {
	if !p.IsSetSuccess() {
		return GetTopologyResult_Success_DEFAULT
	}
	return p.Success
}

var GetTopologyResult_E_DEFAULT *NotAliveException

func (p *GetTopologyResult) GetE() *NotAliveException {
	if !p.IsSetE() {
		return GetTopologyResult_E_DEFAULT
	}
	return p.E
}

var GetTopologyResult_Aze_DEFAULT *AuthorizationException

func (p *GetTopologyResult) GetAze() *AuthorizationException {
	if !p.IsSetAze() {
		return GetTopologyResult_Aze_DEFAULT
	}
	return p.Aze
}
func (p *GetTopologyResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetTopologyResult) IsSetE() bool {
	return p.E != nil
}

func (p *GetTopologyResult) IsSetAze() bool {
	return p.Aze != nil
}

func (p *GetTopologyResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTopologyResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &StormTopology{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *GetTopologyResult) ReadField1(iprot thrift.TProtocol) error {
	p.E = &NotAliveException{}
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E, err)
	}
	return nil
}

func (p *GetTopologyResult) ReadField2(iprot thrift.TProtocol) error {
	p.Aze = &AuthorizationException{}
	if err := p.Aze.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Aze, err)
	}
	return nil
}

func (p *GetTopologyResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTopology_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTopologyResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetTopologyResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetE() {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *GetTopologyResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetAze() {
		if err := oprot.WriteFieldBegin("aze", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:aze: %s", p, err)
		}
		if err := p.Aze.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Aze, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:aze: %s", p, err)
		}
	}
	return err
}

func (p *GetTopologyResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTopologyResult(%+v)", *p)
}

type GetUserTopologyArgs struct {
	Id string `thrift:"id,1" json:"id"`
}

func NewGetUserTopologyArgs() *GetUserTopologyArgs {
	return &GetUserTopologyArgs{}
}

func (p *GetUserTopologyArgs) GetId() string {
	return p.Id
}
func (p *GetUserTopologyArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetUserTopologyArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Id = v
	}
	return nil
}

func (p *GetUserTopologyArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getUserTopology_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetUserTopologyArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("id", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:id: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Id)); err != nil {
		return fmt.Errorf("%T.id (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:id: %s", p, err)
	}
	return err
}

func (p *GetUserTopologyArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetUserTopologyArgs(%+v)", *p)
}

type GetUserTopologyResult struct {
	Success *StormTopology          `thrift:"success,0" json:"success"`
	E       *NotAliveException      `thrift:"e,1" json:"e"`
	Aze     *AuthorizationException `thrift:"aze,2" json:"aze"`
}

func NewGetUserTopologyResult() *GetUserTopologyResult {
	return &GetUserTopologyResult{}
}

var GetUserTopologyResult_Success_DEFAULT *StormTopology

func (p *GetUserTopologyResult) GetSuccess() *StormTopology {
	if !p.IsSetSuccess() {
		return GetUserTopologyResult_Success_DEFAULT
	}
	return p.Success
}

var GetUserTopologyResult_E_DEFAULT *NotAliveException

func (p *GetUserTopologyResult) GetE() *NotAliveException {
	if !p.IsSetE() {
		return GetUserTopologyResult_E_DEFAULT
	}
	return p.E
}

var GetUserTopologyResult_Aze_DEFAULT *AuthorizationException

func (p *GetUserTopologyResult) GetAze() *AuthorizationException {
	if !p.IsSetAze() {
		return GetUserTopologyResult_Aze_DEFAULT
	}
	return p.Aze
}
func (p *GetUserTopologyResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetUserTopologyResult) IsSetE() bool {
	return p.E != nil
}

func (p *GetUserTopologyResult) IsSetAze() bool {
	return p.Aze != nil
}

func (p *GetUserTopologyResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetUserTopologyResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &StormTopology{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *GetUserTopologyResult) ReadField1(iprot thrift.TProtocol) error {
	p.E = &NotAliveException{}
	if err := p.E.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.E, err)
	}
	return nil
}

func (p *GetUserTopologyResult) ReadField2(iprot thrift.TProtocol) error {
	p.Aze = &AuthorizationException{}
	if err := p.Aze.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Aze, err)
	}
	return nil
}

func (p *GetUserTopologyResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getUserTopology_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetUserTopologyResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetUserTopologyResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetE() {
		if err := oprot.WriteFieldBegin("e", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:e: %s", p, err)
		}
		if err := p.E.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.E, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:e: %s", p, err)
		}
	}
	return err
}

func (p *GetUserTopologyResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetAze() {
		if err := oprot.WriteFieldBegin("aze", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:aze: %s", p, err)
		}
		if err := p.Aze.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Aze, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:aze: %s", p, err)
		}
	}
	return err
}

func (p *GetUserTopologyResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetUserTopologyResult(%+v)", *p)
}
